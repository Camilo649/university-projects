<!DOCTYPE html>
<html class="writer-html5" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CUB — cub 3.1 documentation</title>
      <link rel="stylesheet" href="CUB%20%E2%80%94%20cub%203.1%20documentation_files/pygments.css" type="text/css">
      <link rel="stylesheet" href="CUB%20%E2%80%94%20cub%203.1%20documentation_files/theme.css" type="text/css">
      <link rel="stylesheet" href="CUB%20%E2%80%94%20cub%203.1%20documentation_files/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" type="text/css">
      <link rel="stylesheet" href="CUB%20%E2%80%94%20cub%203.1%20documentation_files/omni-style.css" type="text/css">
      <link rel="stylesheet" href="CUB%20%E2%80%94%20cub%203.1%20documentation_files/api-styles.css" type="text/css">
    <link rel="shortcut icon" href="https://nvidia.github.io/cccl/cub/_static/favicon.ico">
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/documentation_options.js"></script>
        <script src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/jquery.js"></script>
        <script src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/underscore.js"></script>
        <script src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/doctools.js"></script>
        <script src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/mermaid-init.js"></script>
        <script src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/design-tabs.js"></script>
        <script src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/mermaid.min.js"></script>
        <script>initMermaid();</script>
        <script src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/version.js"></script>
        <script src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/social-media.js"></script>
    <script src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/theme.js"></script>
    <link rel="index" title="Index" href="https://nvidia.github.io/cccl/cub/genindex.html">
    <link rel="search" title="Search" href="https://nvidia.github.io/cccl/cub/search.html">
    <link rel="next" title="CUB Modules" href="https://nvidia.github.io/cccl/cub/modules.html"> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="#">
            <img src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/logo.png" class="logo" alt="Logo">
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs">
    <input type="hidden" name="check_keywords" value="yes">
    <input type="hidden" name="area" value="default">
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="https://nvidia.github.io/cccl/cub/modules.html">CUB Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="https://nvidia.github.io/cccl/cub/developer_overview.html">CUB Developer Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="https://nvidia.github.io/cccl/cub/test_overview.html">CUB Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="https://nvidia.github.io/cccl/cub/benchmarking.html">CUB Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="https://nvidia.github.io/cccl/cub/tuning.html">CUB Tunings</a></li>
<li class="toctree-l1"><a class="reference internal" href="https://nvidia.github.io/cccl/cub/releases.html">CUB Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="https://nvidia.github.io/cccl/cub/api/cub_api.html">CUB API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">cub</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home"></a> »</li>
      <li>CUB</li>
      <li class="wy-breadcrumbs-aside fa"><span class="social-media-icon"><a href="https://github.com/NVIDIA/cccl"></a></span></li>
  </ul>
  <hr>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="cub">
<span id="cub-module"></span><h1>CUB<a class="headerlink" href="#cub" title="Permalink to this headline"></a></h1>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="what-is-cub">
<h1>What is CUB?<a class="headerlink" href="#what-is-cub" title="Permalink to this headline"></a></h1>
<p>CUB provides state-of-the-art, reusable software components for every layer
of the CUDA programming model:</p>
<ul class="simple">
<li><p><strong>Parallel primitives</strong></p>
<ul>
<li><p><a class="reference internal" href="https://nvidia.github.io/cccl/cub/thread_level.html#thread-module"><span class="std std-ref">Thread</span></a> primitives</p>
<ul>
<li><p>Thread-level reduction, etc.</p></li>
<li><p>Safely specialized for each underlying CUDA architecture</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="https://nvidia.github.io/cccl/cub/warp_wide.html#warp-module"><span class="std std-ref">Warp-wide</span></a> “collective” primitives</p>
<ul>
<li><p>Cooperative warp-wide prefix scan, reduction, etc.</p></li>
<li><p>Safely specialized for each underlying CUDA architecture</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="https://nvidia.github.io/cccl/cub/block_wide.html#block-module"><span class="std std-ref">Block-wide</span></a> “collective” primitives</p>
<ul>
<li><p>Cooperative I/O, sort, scan, reduction, histogram, etc.</p></li>
<li><p>Compatible with arbitrary thread block sizes and types</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="https://nvidia.github.io/cccl/cub/device_wide.html#device-module"><span class="std std-ref">Device-wide</span></a> primitives</p>
<ul>
<li><p>Parallel sort, prefix scan, reduction, histogram, etc.</p></li>
<li><p>Compatible with CUDA dynamic parallelism</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Utilities</strong></p>
<ul>
<li><p><strong>Fancy iterators</strong></p></li>
<li><p><strong>Thread and thread block I/O</strong></p></li>
<li><p><strong>PTX intrinsics</strong></p></li>
<li><p><strong>Device, kernel, and storage management</strong></p></li>
</ul>
</li>
</ul>
</section>
<section id="cub-s-collective-primitives">
<span id="collective-primitives"></span><h1>CUB’s collective primitives<a class="headerlink" href="#cub-s-collective-primitives" title="Permalink to this headline"></a></h1>
<p>Collective software primitives are essential for constructing high-performance,
maintainable CUDA kernel code.  Collectives allow complex parallel code to be
re-used rather than re-implemented, and to be re-compiled rather than
hand-ported.</p>
<figure class="align-center" id="fig-cub-overview">
<img alt="Orientation of collective primitives within the CUDA software stack" src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/cub_overview.png">
<figcaption>
<p><span class="caption-text">Orientation of collective primitives within the CUDA software stack</span><a class="headerlink" href="#fig-cub-overview" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>As a SIMT programming model, CUDA engenders both <strong>scalar</strong> and
<strong>collective</strong> software interfaces. Traditional software
interfaces are <em>scalar</em> : a single thread invokes a library routine to perform some
operation (which may include spawning parallel subtasks). Alternatively, a <em>collective</em>
interface is entered simultaneously by a group of parallel threads to perform
some cooperative operation.</p>
<p>CUB’s collective primitives are not bound to any particular width of parallelism
or data type. This flexibility makes them:</p>
<ul class="simple">
<li><p><strong>Adaptable</strong> to fit the needs of the enclosing kernel computation</p></li>
<li><p><strong>Trivially tunable</strong> to different grain sizes (threads per block, items per thread, etc.)</p></li>
</ul>
<p>Thus CUB is <em>CUDA Unbound</em>.</p>
</section>
<section id="an-example-block-wide-sorting">
<h1>An example (block-wide sorting)<a class="headerlink" href="#an-example-block-wide-sorting" title="Permalink to this headline"></a></h1>
<p>The following code snippet presents a CUDA kernel in which each block of <code class="docutils literal notranslate"><span class="pre">BLOCK_THREADS</span></code> threads
will collectively load, sort, and store its own segment of (<code class="docutils literal notranslate"><span class="pre">BLOCK_THREADS</span> <span class="pre">*</span> <span class="pre">ITEMS_PER_THREAD</span></code>)
integer keys:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cub/cub.cuh&gt;</span><span class="cp"></span>

<span class="c1">//</span>
<span class="c1">// Block-sorting CUDA kernel</span>
<span class="c1">//</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">BLOCK_THREADS</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ITEMS_PER_THREAD</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">BlockSortKernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">d_in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">d_out</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Specialize BlockLoad, BlockStore, and BlockRadixSort collective types</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BlockLoadT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockLoad</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">ITEMS_PER_THREAD</span><span class="p">,</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BLOCK_LOAD_TRANSPOSE</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BlockStoreT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockStore</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">ITEMS_PER_THREAD</span><span class="p">,</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BLOCK_STORE_TRANSPOSE</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">BlockRadixSortT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockRadixSort</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">ITEMS_PER_THREAD</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate type-safe, repurposable shared memory for collectives</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockLoadT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w">       </span><span class="n">load</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockStoreT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w">      </span><span class="n">store</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockRadixSortT</span><span class="o">::</span><span class="n">TempStorage</span><span class="w">  </span><span class="n">sort</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">temp_storage</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Obtain this block's segment of consecutive keys (blocked across threads)</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_keys</span><span class="p">[</span><span class="n">ITEMS_PER_THREAD</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">BLOCK_THREADS</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ITEMS_PER_THREAD</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">BlockLoadT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">load</span><span class="p">).</span><span class="n">Load</span><span class="p">(</span><span class="n">d_in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_keys</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w">        </span><span class="c1">// Barrier for smem reuse</span>

<span class="w">    </span><span class="c1">// Collectively sort the keys</span>
<span class="w">    </span><span class="n">BlockRadixSortT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">sort</span><span class="p">).</span><span class="n">Sort</span><span class="p">(</span><span class="n">thread_keys</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w">        </span><span class="c1">// Barrier for smem reuse</span>

<span class="w">    </span><span class="c1">// Store the sorted segment</span>
<span class="w">    </span><span class="n">BlockStoreT</span><span class="p">(</span><span class="n">temp_storage</span><span class="p">.</span><span class="n">store</span><span class="p">).</span><span class="n">Store</span><span class="p">(</span><span class="n">d_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">thread_keys</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Elsewhere in the host program: parameterize and launch a block-sorting</span>
<span class="c1">// kernel in which blocks of 128 threads each sort segments of 2048 keys</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">d_in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">d_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">num_blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">BlockSortKernel</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">num_blocks</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">d_in</span><span class="p">,</span><span class="w"> </span><span class="n">d_out</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, threads use <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code>, <code class="docutils literal notranslate"><span class="pre">cub::BlockRadixSort</span></code>, and <code class="docutils literal notranslate"><span class="pre">cub::BlockStore</span></code>
to collectively load, sort and store the block’s segment of input items.  Because these operations
are cooperative, each primitive requires an allocation of shared memory for threads to communicate
through. The typical usage pattern for a CUB collective is:</p>
<ol class="arabic simple">
<li><p>Statically specialize the primitive for the specific problem setting at hand, e.g.,
the data type being sorted, the number of threads per block, the number of keys per
thread, optional algorithmic alternatives, etc. (CUB primitives are also implicitly
specialized by the targeted compilation architecture.)</p></li>
<li><p>Allocate (or alias) an instance of the specialized primitive’s nested <code class="docutils literal notranslate"><span class="pre">TempStorage</span></code>
type within a shared memory space.</p></li>
<li><p>Specify communication details (e.g., the <code class="docutils literal notranslate"><span class="pre">TempStorage</span></code> allocation) to
construct an instance of the primitive.</p></li>
<li><p>Invoke methods on the primitive instance.</p></li>
</ol>
<p>In particular, <code class="docutils literal notranslate"><span class="pre">cub::BlockRadixSort</span></code> is used to collectively sort the segment of data items
that have been partitioned across the thread block. To provide coalesced accesses
to device memory,  we configure the <code class="docutils literal notranslate"><span class="pre">cub::BlockLoad</span></code> and <code class="docutils literal notranslate"><span class="pre">cub::BlockStore</span></code> primitives
to access memory using a striped access pattern (where consecutive threads
simultaneously access consecutive items) and then <em>transpose</em> the keys into
a <a class="reference internal" href="#flexible-data-arrangement"><span class="std std-ref">blocked arrangement</span></a> of elements across threads.
To reuse shared memory across all three primitives, the thread block statically
allocates a union of their <code class="docutils literal notranslate"><span class="pre">TempStorage</span></code> types.</p>
</section>
<section id="why-do-you-need-cub">
<h1>Why do you need CUB?<a class="headerlink" href="#why-do-you-need-cub" title="Permalink to this headline"></a></h1>
<p>Writing, tuning, and maintaining kernel code is perhaps the most challenging,
time-consuming aspect of CUDA programming.  Kernel software is where
the complexity of parallelism is expressed. Programmers must reason about
deadlock, livelock, synchronization, race conditions, shared memory layout,
plurality of state, granularity, throughput, latency, memory bottlenecks, etc.</p>
<p>With the exception of CUB, however, there are few (if any) software libraries of
<em>reusable</em> kernel primitives. In the CUDA ecosystem, CUB is unique in this regard.
As a <a class="reference external" href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#hardware-implementation">SIMT</a>
library and software abstraction layer, CUB provides:</p>
<ol class="arabic">
<li><p><strong>Simplicity of composition</strong>. CUB enhances programmer productivity by
allowing complex parallel operations to be easily sequenced and nested.
For example, <code class="docutils literal notranslate"><span class="pre">cub::BlockRadixSort</span></code> is constructed from <code class="docutils literal notranslate"><span class="pre">cub::BlockExchange</span></code> and
<code class="docutils literal notranslate"><span class="pre">cub::BlockRadixRank</span></code>. The latter is composed of <code class="docutils literal notranslate"><span class="pre">cub::BlockScan</span></code>
which incorporates <code class="docutils literal notranslate"><span class="pre">cub::WarpScan</span></code>.</p>
<figure class="align-center">
<img alt="_images/nested_composition.png" src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/nested_composition.png">
</figure>
</li>
<li><p><strong>High performance</strong>. CUB simplifies high-performance program and kernel
development by taking care to implement the state-of-the-art in parallel algorithms.</p></li>
<li><p><strong>Performance portability</strong>.
CUB primitives are specialized to match the diversity of NVIDIA hardware, continuously
evolving to accommodate new architecture-specific features and instructions.  And
because CUB’s device-wide primitives are implemented using flexible block-wide and
warp-wide collectives, we are able to performance-tune them to match the processor
resources provided by each CUDA processor architecture.</p></li>
<li><p><strong>Simplicity of performance tuning</strong>:</p>
<ul class="simple">
<li><p><strong>Resource utilization</strong>.  CUB primitives allow developers to quickly
change grain sizes (threads per block, items per thread, etc.) to best match
the processor resources of their target architecture</p></li>
<li><p><strong>Variant tuning</strong>.  Most CUB primitives support alternative algorithmic
strategies. For example, <code class="docutils literal notranslate"><span class="pre">cub::BlockHistogram</span></code> is parameterized to implement either
an atomic-based approach or a sorting-based approach. (The latter provides uniform
performance regardless of input distribution.)</p></li>
<li><p><strong>Co-optimization</strong>.  When the enclosing kernel
is similarly parameterizable, a tuning configuration can be found that optimally
accommodates their combined register and shared memory pressure.</p></li>
</ul>
</li>
<li><p><strong>Robustness and durability</strong>. CUB just works. CUB primitives
are designed to function properly for arbitrary data types and widths of
parallelism (not just for the built-in C++ types or for powers-of-two threads
per block).</p></li>
<li><p><strong>Reduced maintenance burden</strong>. CUB provides a SIMT software abstraction layer
over the diversity of CUDA hardware. With CUB, applications can enjoy
performance-portability without intensive and costly rewriting or porting efforts.</p></li>
<li><p><strong>A path for language evolution</strong>. CUB primitives are designed
to easily accommodate new features in the CUDA programming model, e.g., thread
subgroups and named barriers, dynamic shared memory allocators, etc.</p></li>
</ol>
</section>
<section id="how-do-cub-collectives-work">
<h1>How do CUB collectives work?<a class="headerlink" href="#how-do-cub-collectives-work" title="Permalink to this headline"></a></h1>
<p>Four programming idioms are central to the design of CUB:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#generic-programming"><span class="std std-ref">Generic programming</span></a>. C++ templates provide the flexibility
and adaptive code generation needed for CUB primitives to be useful, reusable, and
fast in arbitrary kernel settings.</p></li>
<li><p><a class="reference internal" href="#reflective-class-interfaces"><span class="std std-ref">Reflective class interfaces</span></a>.
CUB collectives statically export their their resource requirements
(e.g., shared memory size and layout) for a given specialization, which allows compile-time
tuning decisions and resource allocation.</p></li>
<li><p><a class="reference internal" href="#flexible-data-arrangement"><span class="std std-ref">Flexible data arrangement across threads</span></a>.
CUB collectives operate on data that is logically partitioned across a group of threads.
For most collective operations, efficiency is increased with increased granularity
(i.e., items per thread).</p></li>
<li><p><a class="reference internal" href="#static-tuning-and-co-tuning"><span class="std std-ref">Static tuning and co-tuning</span></a>. Simple constants and static
types dictate the granularities and algorithmic alternatives to be employed by CUB collectives.
When the enclosing kernel is similarly parameterized, an optimal configuration can be determined
that best accommodates the combined behavior and resource consumption of all primitives within
the kernel.</p></li>
</ol>
<section id="generic-programming">
<span id="id1"></span><h2>Generic programming<a class="headerlink" href="#generic-programming" title="Permalink to this headline"></a></h2>
<p>We use template parameters to specialize CUB primitives for the particular
problem setting at hand.  Until compile time, CUB primitives are not bound
to any particular:</p>
<ul class="simple">
<li><p>Data type (int, float, double, etc.)</p></li>
<li><p>Width of parallelism (threads per thread block)</p></li>
<li><p>Grain size (data items per thread)</p></li>
<li><p>Underlying processor (special instructions, warp size, rules for bank conflicts, etc.)</p></li>
<li><p>Tuning configuration (e.g., latency vs. throughput, algorithm selection, etc.)</p></li>
</ul>
</section>
<section id="reflective-class-interfaces">
<span id="id2"></span><h2>Reflective class interfaces<a class="headerlink" href="#reflective-class-interfaces" title="Permalink to this headline"></a></h2>
<p>Unlike traditional function-oriented interfaces, CUB exposes its collective
primitives as templated C++ classes. The resource requirements for a specific
parameterization are reflectively advertised as members of the class. The
resources can then be statically or dynamically allocated, aliased
to global or shared memory, etc.  The following illustrates a CUDA kernel
fragment performing a collective prefix sum across the threads of a thread block:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cub/cub.cuh&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">SomeKernelFoo</span><span class="p">(...)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Specialize BlockScan for 128 threads on integer types</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BlockScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cub</span><span class="o">::</span><span class="n">BlockScan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Allocate shared memory for BlockScan</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BlockScan</span><span class="o">::</span><span class="n">TempStorage</span><span class="w"> </span><span class="n">scan_storage</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="p">...</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Obtain a segment of consecutive items that are blocked across threads</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data_in</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_data_out</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Perform an exclusive block-wide prefix sum</span>
<span class="w">  </span><span class="n">BlockScan</span><span class="p">(</span><span class="n">scan_storage</span><span class="p">).</span><span class="n">ExclusiveSum</span><span class="p">(</span><span class="n">thread_data_in</span><span class="p">,</span><span class="w"> </span><span class="n">thread_data_out</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Furthermore, the CUB interface is designed to separate parameter
fields by concerns. CUB primitives have three distinct parameter fields:</p>
<ol class="arabic simple">
<li><p><em>Static template parameters</em>. These are constants that will
dictate the storage layout and the unrolling of algorithmic steps (e.g.,
the input data type and the number of block threads), and are used to specialize the class.</p></li>
<li><p><em>Constructor parameters</em>. These are optional parameters regarding
inter-thread communication (e.g., storage allocation, thread-identifier mapping,
named barriers, etc.), and are orthogonal to the functions exposed by the class.</p></li>
<li><p><em>Formal method parameters</em>. These are the operational inputs/outputs
for the various functions exposed by the class.</p></li>
</ol>
<p>This allows CUB types to easily accommodate new
programming model features (e.g., named barriers, memory allocators, etc.)
without incurring a combinatorial growth of interface methods.</p>
</section>
<section id="flexible-data-arrangement-across-threads">
<span id="flexible-data-arrangement"></span><h2>Flexible data arrangement across threads<a class="headerlink" href="#flexible-data-arrangement-across-threads" title="Permalink to this headline"></a></h2>
<p>CUDA kernels are often designed such that each thread block is assigned a
segment of data items for processing.</p>
<figure class="align-center" id="fig-tile">
<img alt="Segment of eight ordered data items" src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/tile.png">
<figcaption>
<p><span class="caption-text">Segment of eight ordered data items</span><a class="headerlink" href="#fig-tile" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>When the tile size equals the thread block size, the
mapping of data onto threads is straightforward (one datum per thread).
However, there are often performance advantages for processing more
than one datum per thread. Increased granularity corresponds to
decreased communication overhead. For these scenarios, CUB primitives
will specify which of the following partitioning alternatives they
accommodate:</p>
<div class="wy-table-responsive"><table class="colwidths-given table-no-stripes docutils align-default">
<colgroup>
<col style="width: 70%">
<col style="width: 30%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Blocked arrangement</strong>.  The aggregate tile of items is partitioned
evenly across threads in “blocked” fashion with <em>thread</em><sub>i</sub>
owning the <em>i</em><sup>th</sup> segment of consecutive elements.
Blocked arrangements are often desirable for algorithmic benefits (where
long sequences of items can be processed sequentially within each thread).</p></td>
<td><figure class="align-center" id="fig-blocked">
<img alt="*Blocked* arrangement across four threads" src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/blocked.png">
<figcaption>
<p><span class="caption-text"><em>Blocked</em> arrangement across four threads</span><a class="headerlink" href="#fig-blocked" title="Permalink to this image"></a></p>
<div class="legend">
<p>(emphasis on items owned by <em>thread</em><sub>0</sub>)</p>
</div>
</figcaption>
</figure>
</td>
</tr>
<tr class="row-even"><td><p><strong>Striped arrangement</strong>. The aggregate tile of items is partitioned across threads in “striped”
fashion, i.e., the <code class="docutils literal notranslate"><span class="pre">ITEMS_PER_THREAD</span></code> items owned by each thread have logical stride
<code class="docutils literal notranslate"><span class="pre">BLOCK_THREADS</span></code> between them. Striped arrangements are often desirable for data movement through
global memory (where
<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#coalesced-access-to-global-memory">read/write coalescing</a>
is an important performance consideration).</p></td>
<td><figure class="align-center" id="fig-striped">
<img alt="*Striped* arrangement across four threads" src="CUB%20%E2%80%94%20cub%203.1%20documentation_files/striped.png">
<figcaption>
<p><span class="caption-text"><em>Striped</em> arrangement across four threads</span><a class="headerlink" href="#fig-striped" title="Permalink to this image"></a></p>
<div class="legend">
<p>(emphasis on items owned by <em>thread</em><sub>0</sub>)</p>
</div>
</figcaption>
</figure>
</td>
</tr>
</tbody>
</table></div>
<p>The benefits of processing multiple items per thread (a.k.a., <em>register blocking</em>,
<em>granularity coarsening</em>, etc.) include:</p>
<ul class="simple">
<li><p>Algorithmic efficiency.  Sequential work over multiple items in
thread-private registers is cheaper than synchronized, cooperative
work through shared memory spaces.</p></li>
<li><p>Data occupancy.  The number of items that can be resident on-chip in
thread-private register storage is often greater than the number of
schedulable threads.</p></li>
<li><p>Instruction-level parallelism.  Multiple items per thread also
facilitates greater ILP for improved throughput and utilization.</p></li>
</ul>
<p>Finally, <code class="docutils literal notranslate"><span class="pre">cub::BlockExchange</span></code> provides operations for converting between blocked
and striped arrangements.</p>
</section>
<section id="static-tuning-and-co-tuning">
<span id="id3"></span><h2>Static tuning and co-tuning<a class="headerlink" href="#static-tuning-and-co-tuning" title="Permalink to this headline"></a></h2>
<p>This style of flexible interface simplifies performance tuning. Most CUB
primitives support alternative algorithmic strategies that can be
statically targeted by a compiler-based or JIT-based autotuner. (For
example, <code class="docutils literal notranslate"><span class="pre">cub::BlockHistogram</span></code> is parameterized to implement either an
atomic-based approach or a sorting-based approach.) Algorithms are also
tunable over parameters such as thread count and grain size as well.
Taken together, each of the CUB algorithms provides a fairly rich tuning
space.</p>
<p>Whereas conventional libraries are optimized offline and in isolation, CUB
provides interesting opportunities for whole-program optimization. For
example, each CUB primitive is typically parameterized by threads-per-block
and items-per-thread, both of which affect the underlying algorithm’s
efficiency and resource requirements. When the enclosing kernel is similarly
parameterized, the coupled CUB primitives adjust accordingly. This enables
autotuners to search for a single configuration that maximizes the performance
of the entire kernel for a given set of hardware resources.</p>
</section>
</section>
<section id="how-do-i-get-started-using-cub">
<h1>How do I get started using CUB?<a class="headerlink" href="#how-do-i-get-started-using-cub" title="Permalink to this headline"></a></h1>
<p>CUB is implemented as a C++ header library. There is no need to build CUB
separately. To use CUB primitives in your code, simply:</p>
<ol class="arabic simple">
<li><p>Download and unzip the latest CUB distribution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#include</span></code> the “umbrella” <code class="docutils literal notranslate"><span class="pre">&lt;cub/cub.cuh&gt;</span></code> header file in
your CUDA C++ sources.  (Or <code class="docutils literal notranslate"><span class="pre">#include</span></code> the particular
header files that define the CUB primitives you wish to use.)</p></li>
<li><p>Compile your program with NVIDIA’s <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> CUDA compiler,
specifying a <code class="docutils literal notranslate"><span class="pre">-I&lt;path-to-CUB&gt;</span></code> include-path flag to reference
the location of the CUB header library.</p></li>
</ol>
<p>We also have a collection of simple CUB example programs.</p>
</section>
<section id="how-is-cub-different-than-thrust-and-modern-gpu">
<h1>How is CUB different than Thrust and Modern GPU?<a class="headerlink" href="#how-is-cub-different-than-thrust-and-modern-gpu" title="Permalink to this headline"></a></h1>
<section id="cub-and-thrust">
<h2>CUB and Thrust<a class="headerlink" href="#cub-and-thrust" title="Permalink to this headline"></a></h2>
<p>CUB and <a class="reference external" href="https://nvidia.github.io/cccl/thrust/">Thrust</a> share some
similarities in that they both provide similar device-wide primitives for CUDA.
However, they target different abstraction layers for parallel computing.
Thrust abstractions are agnostic of any particular parallel framework (e.g.,
CUDA, TBB, OpenMP, sequential  CPU, etc.).  While Thrust has a “backend”
for CUDA devices, Thrust interfaces themselves are not CUDA-specific and
do not explicitly expose CUDA-specific details (e.g., <code class="docutils literal notranslate"><span class="pre">cudaStream_t</span></code> parameters).</p>
<p>CUB, on the other hand, is slightly lower-level than Thrust. CUB is specific
to CUDA C++ and its interfaces explicitly accommodate CUDA-specific features.
Furthermore, CUB is also a library of SIMT collective primitives for block-wide
and warp-wide kernel programming.</p>
<p>CUB and Thrust are complementary and can be used together. In fact, the CUB
project arose out of a maintenance need to achieve better performance-portability
within Thrust by using reusable block-wide primitives to reduce maintenance and
tuning effort.</p>
</section>
<section id="cub-and-modern-gpu">
<h2>CUB and Modern GPU<a class="headerlink" href="#cub-and-modern-gpu" title="Permalink to this headline"></a></h2>
<p>CUB and <a class="reference external" href="https://github.com/moderngpu/moderngpu">Modern GPU</a> also
share some similarities in that they both implement similar device-wide primitives for CUDA.
However, they serve different purposes for the CUDA programming community.  MGPU
is a pedagogical tool for high-performance GPU computing, providing clear and concise
exemplary code and accompanying commentary.  It serves as an excellent source of
educational, tutorial, CUDA-by-example material.  The MGPU source code is intended
to be read and studied, and often favors simplicity at the expense of portability and
flexibility.</p>
<p>CUB, on the other hand, is a production-quality library whose sources are complicated
by support for every version of CUDA architecture, and is validated by an extensive
suite of regression tests.  Although well-documented, the CUB source text is verbose
and relies heavily on C++ template metaprogramming for situational specialization.</p>
<p>CUB and MGPU are complementary in that MGPU serves as an excellent descriptive source
for many of the algorithmic techniques used by CUB.</p>
</section>
</section>
<section id="stable-releases">
<h1>Stable releases<a class="headerlink" href="#stable-releases" title="Permalink to this headline"></a></h1>
<p>CUB releases are labeled using version identifiers having three fields:
<code class="docutils literal notranslate"><span class="pre">&lt;epoch&gt;.&lt;feature&gt;.&lt;update&gt;</span></code>. The <em>epoch</em> field
corresponds to support for a major change or update to the CUDA programming model.
The <em>feature</em> field corresponds to a stable set of features,
functionality, and interface. The <em>update</em> field corresponds to a
bug-fix or performance update for that feature set.  At the moment, we do
not publicly provide non-stable releases such as development snapshots,
beta releases or rolling releases. (Feel free to contact us if you would
like access to such things.)</p>
</section>
<section id="contributors">
<h1>Contributors<a class="headerlink" href="#contributors" title="Permalink to this headline"></a></h1>
<p>CUB is developed as an open-source project by NVIDIA.
The primary contributor is the CCCL team.</p>
</section>
<section id="open-source-license">
<h1>Open Source License<a class="headerlink" href="#open-source-license" title="Permalink to this headline"></a></h1>
<p>CUB is available under the <a class="reference external" href="https://github.com/NVIDIA/cub/blob/main/LICENSE.TXT">BSD 3-Clause “New” or “Revised” License</a></p>
</section>


           </div>
          </div>
          <footer>

  <hr>

  <div role="contentinfo">
    <p>© Copyright 2025, NVIDIA.
      <span class="lastupdated">Last updated on Jun 06, 2025.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 


</body></html>